
  
readBrainData <- function(filename, filetype=NULL) {
  filestem <- strsplit(filename, split="\\.")[[1]][[1]]
  filedir <- dirname(filename)
  candidates <- list.files(filedir, paste("^", filestem, ".*", sep=""))

  filepair <- NULL
  if (is.null(filetype)) {
    filepair <- validCandidates(candidates)
  } else {
    ext <- getExtensions(filetype)
    filepair <- list(header=paste(filestem, ext$header, sep="."), data=paste(filestem, ext$data, sep="."))
  }

  return(filepair)
    
}


validCandidates <- function(candidates) {
  res <- lapply(c(".nii", ".hdr", "nii.gz", "hdr.gz", "img.gz"), regexpr, candidates)
  idx = lapply(res, function(tmp) which(tmp != -1))
  candidates <- candidates[unlist(idx)]
  candidates <- sort(candidates)
  

  if (length(candidates) == 3) {
    stop(paste("cannot resolve filenames: multiple possibiliites:", candidates))
  } else if (length(candidates) == 2) {
    
    if (isExtension(candidates[1],".hdr") && isExtension(candidates[2], ".img")) {
      return(list(header=candidates[1], data=candidates[2]))
    } else if (isExtension(candidates[1],".hdr.gz") && isExtension(candidates[2], ".img.gz")) {
      return(list(header=candidates[1], data=candidates[2]))
    }
  } else if (length(candidates) == 1) {
    if (isExtension(candidates[1],".nii")) {
      return(list(header=candidates[1], data=candidates[1]))
    } else if (isExtension(candidates[1],".nii.gz")) {
      return(list(header=candidates[1], data=candidates[1]))
    }
  }

  return(NULL)
}

getExtensions <- function(filetype) {
  extensions <- list()
  
  if (filetype == "NIFTI") {
    extensions[["header"]]  <- "nii"
    extensions[["data"]] <- "nii"
  }
  else if (filetype == "NIFTI_PAIR") {
    extensions[["header"]]  <- "hdr"
    extensions[["data"]] <- "img"
  }
  else if (filetype == "ANALYZE") {
    extensions[["header"]]  <- "hdr"
    extensions[["data"]] <- "img"
  }
  else if (filetype == "NIFTI_GZ") {
    extensions[["header"]]  <- "nii.gz"
    extensions[["data"]] <- "nii.gz"
  } else {
    stop(paste("unsupported filetype: ", filetype))
  }

  return(extensions)
}


readAnalyzeHeader <- function(fname) {

  if (! (isExtension(fname, ".hdr") || isExtension(fname, ".hdr.gz"))) {
    stop(paste("readAnalyzeHeader: supplied filename:", fname, "is not an analyze header"))
  }
  
  header = list()

  
  conn = file(fname, open="rb")
  header$endian = getEndian(conn)
  header$filetype = "ANALYZE"
  header$version="7.5"
  header$encoding="binary"

  header$headerFile = fname
  header$dataFile = paste(substr(fname, 1, nchar(fname)-4), ".img", sep="")
  
  tmp = readBin(hfile, integer(), n=10, size=1, endian=endian)
  seek(hfile, 18, origin="current") # db_name
  seek(hfile, 4, origin="current")  # extents
  seek(hfile, 2, origin="current")  # session_error
  seek(hfile, 1, origin="current")  # regular
  seek(hfile, 1, origin="current")  # hkey_un0

  
  dimensions = readBin(hfile, integer(), n=8, size=2, endian=endian)
  header$dimensions = dimensions[2:5]
  
  seek(hfile, 12, origin="current") # 4 vox_units, 8 cal_units
  seek(hfile, 2, origin="current")  # unused_short
  header$datatype <- readBin(hfile, integer(), n=1, size=2, endian=endian)
  header$dataStorage <- getDataStorage(header$datatype) 
 

  header$bitpix = readBin(hfile, integer(), n=1, size=2, endian=endian)

  seek(hfile, 2, origin="current")  # unused_short

  header$pixdim = readBin(hfile, double(), n=8, size=4, endian=endian)[2:4]
  header$voxOffset = readBin(hfile, double(), n=1, size=4, endian=endian)
  header$sclSlope = readBin(hfile, double(), n=1, size=4, endian=endian)
  hdr = new("ANALYZEHeader", headerFile=headerFile, dataFile=dataFile, fileType=fileType, versionNum=version, encoding=encoding, endian=endian, voxelOffset=header$voxOffset, dataType=header$dataStorage, info=header)
  
    
  close(hfile)

}

createNIFTIInfo <- function(fname, data, header, brainSpace=NULL, encoding="binary", endian=.Platform$endian) {
  if(!isExtension(fname,".nii")) {
    fname = paste(fname, ".nii", sep="")
  }

  if (is.null(brainSpace)) {
    brainSpace <- space(data)
    ndim <- numdim(brainSpace)
    dims <- dimension(brainSpace)
  }
 
      
  ndim <- numdim(brainSpace)
  dims <- dimension(brainSpace)
      
  info <- list()
  info$version <- "1.1"
  info$headerFile <- fname
  info$dataFile <- fname
  info$endian <- endian
  info$encoding <- encoding
  
  info$diminfo <- 0

  odims <- rep(1,8)
  odims[2:(length(dims)+1)] = dims
  
  odims[1] <- ndim
  info$dimensions <- odims
  info$numDimensions <- ndim

  info$intent1 <- 0
  info$intent2 <- 0
  info$intent3 <- 0

  info$intentCode <- 0
  info$datatype <- getDataCode(dataType(header))
  info$dataStorage <- getDataStorage(info$datatype)
  info$bitpix <- getDataSize(header)*8
  info$sliceStart <- 0
  info$pixdim <- c(1, spacing(brainSpace))
  info$pixdim = c(info$pixdim, rep(1, (8-length(info$pixdim))))
  info$qfac <- 1
  info$voxOffset <- 352 # assumes single .nii file
  info$sclSlope <- 0
  info$sclIntercept <- 0
  info$sliceEnd <- dims[3]-1
  info$sliceCode <- 0
  info$xyztUnits <- 2  # assumes MM units
  info$calMax <- 0
  info$calMin <- 0
  info$sliceDuration <- 0
  info$toffset <- 0
  info$glmax <- 0
  info$glmin <- 0
  info$description <- integer(80)
  info$auxfile <- integer(24)

  info$qformCode <- 1 # scanner-based anatomy as default
  info$sformCode <- 1
  info$quaternion <- c(0,0,0) # no rotations
  info$qoffset <- origin(brainSpace)
  info$sform <- quaternToMatrix(info$quaternion, info$qoffset, info$pixdim[2:4], info$qfac)
  info$sform <- info$sform[1:3,] # trim last row
  info$intentName <- integer(16)
  info$onefile <- T
  info$version <- "1.1"
  info$magic <- "n+1"
  
  return(info)
}

writeNIFTIData <- function(volume, fileStem=NULL) {
 
  if (!isExtension(fileStem, ".nii")) {
    fileStem <- paste(fileStem, ".nii", sep="")
  }

  
  hdr <- header(volume)
  
  conn <- writeNIFTIHeader(info(hdr), conn=NULL, headerFile=fileStem)
  data <- values(volume)

  info <- info(hdr)

  
  seek(conn, info$voxOffset)
  if (info$dataStorage == "BINARY") {
    writeBin(as.logical(data), conn, 1, endian=info$endian)
  } else if (info$dataStorage == "UBYTE") {
    writeBin(as.integer(data), conn, 1, endian=info$endian)
  } else if (info$dataStorage == "SHORT") {
    writeBin(as.integer(data), conn, 2, endian=info$endian)
  } else if (info$dataStorage == "INT") {
    writeBin(as.integer(data), conn, 4, endian=info$endian)
  } else if (info$dataStorage == "FLOAT") {
    writeBin(as.double(data), conn, 4, endian=info$endian)
  } else if (info$dataStorage == "DOUBLE") {
    writeBin(as.double(data), conn, 8, endian=info$endian)
  } else {
    stop(paste("unsupported output data type: ", info$dataStorage))
  }

  close(conn)
  
}

writeNIFTIHeader <- function(niftiInfo, conn=NULL, endian=.Platform$endian, headerFile=NULL) {

  #browser()
  if (is.null(conn)) {
    #check if name already exists
    if (!is.null(headerFile)) {
      if (file.exists(headerFile)) {
        stop(paste("file ", headerFile, " already exists. aborting"))
      }
      conn <- file(headerFile, open="wb")
    } else {
      if (file.exists(headerFile)) {
        stop(paste("file ", headerFile, " already exists. aborting"))
      }

      headerFile <- niftiInfo$headerFile       
      conn <- file(headerFile, open="wb")
    }
    
    #check if conn is good
  }

 
  if (is.null(endian)) {
    endian <- niftiInfo$endian
  }
  

  print(paste("endian = ", endian))
  
  writeBin(as.integer(348), conn, 4, endian)
  print(paste("after sizeof_hdr: ", seek(conn)))
  
  writeBin(integer(34),conn,1,endian)
  
  writeChar("r", conn,1,eos=NULL)
  print(paste("after regular: ", seek(conn)))
  
 
  
 
  #diminfo, not supported currently -- write zero
  writeBin(as.integer(niftiInfo$diminfo), conn, size=1, endian)
  print(paste("after dim_info: ", seek(conn)))
  #dimensions
  writeBin(as.integer(niftiInfo$ndim), conn, 2, endian)

  
  
  writeBin(as.integer(niftiInfo$dimensions), conn, 2, endian)

  #intents not supported

  writeBin(as.double(niftiInfo$intent1), conn, 4, endian)
  writeBin(as.double(niftiInfo$intent2), conn, 4, endian)
  writeBin(as.double(niftiInfo$intent3), conn, 4, endian)
  writeBin(as.integer(niftiInfo$intentCode), conn, 2, endian)
  print(paste("after intentCode: ", seek(conn)))
  #datatype
  writeBin(as.integer(niftiInfo$datatype),conn, 2, endian)

  # bits per pixel
  writeBin(as.integer(niftiInfo$bitpix),conn, 2, endian)

  #slice_start
  writeBin(as.integer(niftiInfo$sliceStart),conn, 2, endian)

  #pixdim
  writeBin(as.double(niftiInfo$pixdim), conn, 4, endian)

  #voxOffset
  writeBin(as.double(niftiInfo$voxOffset), conn, 4, endian)

  #sclSlope
  writeBin(as.double(niftiInfo$sclSlope), conn, 4, endian)

  #sclIntercept
  writeBin(as.double(niftiInfo$sclIntercept), conn, 4, endian)

  #sliceEnd
  writeBin(as.integer(niftiInfo$sliceEnd), conn, 2, endian)

  #sliceCode
  writeBin(as.integer(niftiInfo$sliceCode), conn, 1, endian)

  #xyztUnits
  writeBin(as.integer(niftiInfo$xyztUnits), conn, 1, endian)

  #calMax
  writeBin(as.double(niftiInfo$calMax), conn, 4, endian)
  #calMin
  writeBin(as.double(niftiInfo$calMin), conn, 4, endian)

  #sliceDuration
  writeBin(as.double(niftiInfo$sliceDuration), conn, 4, endian)
  
  #toffset
  writeBin(as.double(niftiInfo$toffset), conn, 4, endian)

  #glmax
  writeBin(as.integer(niftiInfo$glmax), conn, 4, endian)
  #glmin
  writeBin(as.integer(niftiInfo$glmin), conn, 4, endian)

  #description
  writeBin(as.integer(niftiInfo$description), conn, 1, endian)
  #aux_file
  writeBin(as.integer(niftiInfo$auxfile), conn, 1, endian)

  #qformCode
  writeBin(as.integer(niftiInfo$qformCode), conn, 2, endian)

  #sformCode
  writeBin(as.integer(niftiInfo$sformCode), conn, 2, endian)

  #quaternion
  writeBin(as.double(niftiInfo$quaternion), conn, 4, endian)

  #qoffset
  writeBin(as.double(niftiInfo$qoffset), conn, 4, endian)

  #sform
  writeBin(as.double(t(niftiInfo$sform[1:3,])), conn, 4, endian)

  #intentName
  writeBin(as.integer(niftiInfo$intentName), conn, 1, endian)

  #magic
  writeChar(niftiInfo$magic, conn)

  return(conn)
 } 

readNIFTIHeader <- function(fname) {
  if (! (isExtension(fname, ".nii") || isExtension(fname, ".nii.gz"))) {
    stop(paste("readNIFTIHeader: supplied filename:", fname, "is not an nifti header"))
  }

  #browser()

  
  header <- list()
  
  #assumes .nii "one file" for now
  
  headerFile <- fname
  dataFile <- fname

  header$headerFile <- headerFile
  header$dataFile <- dataFile
  
  fileType="NIFTI"
  header$encoding <- "binary"
  version <- "1"
  

  conn <- NULL
  if (isExtension(fname, ".nii")) {
    conn <- file(fname, open="rb")
  } else if (isExtension(fname, ".nii.gz")) {
    conn <- gzfile(fname, open="rb")
    header$encoding <- "gzip"
  }

  
  endian <- getEndian(conn)
  header$endian <- endian
  

  #unused fields
  readBin(conn, what=integer(), n=10+18+4+2+1, size=1)

  header$diminfo <- readBin(conn, what=integer(), n=1, size=1, endian=endian)
  header$dimensions <- readBin(conn, integer(), n=8, size=2, endian=endian)
  checkDimensions(header$dimensions)
  header$numDimensions <- header$dimensions[1]

  header$intent1 <-  readBin(conn, double(), n=1, size=4, endian=endian)
  header$intent2 <-  readBin(conn, double(), n=1, size=4, endian=endian)
  header$intent3 <-  readBin(conn, double(), n=1, size=4, endian=endian)

 
  header$intentCode <-  readBin(conn, integer(), n=1, size=2, endian=endian)
  header$datatype <- readBin(conn, integer(), n=1, size=2, endian=endian)
  header$dataStorage <- getDataStorage(header$datatype)
  header$bitpix <- readBin(conn, integer(), n=1, size=2, endian=endian)
  header$sliceStart <- readBin(conn, integer(), n=1, size=2, endian=endian)
  header$pixdim <-  readBin(conn, double(), n=8, size=4, endian=endian)

  header$qfac = header$pixdim[1]
  if (header$qfac == 0) {
    header$qfac = 1
  }

  header$voxOffset <- readBin(conn, double(), n=1, size=4, endian=endian)
  header$sclSlope <- readBin(conn, double(), n=1, size=4, endian=endian)
  header$sclIntercept <- readBin(conn, double(), n=1, size=4, endian=endian)
  header$sliceEnd <- readBin(conn, integer(), n=1, size=2, endian=endian)
  header$sliceCode <-  readBin(conn, integer(), n=1, size=1, endian=endian)
  

  header$xyztUnits <- readBin(conn, integer(), n=1, size=1, endian=endian)
  header$calMax <- readBin(conn, double(), n=1, size=4, endian=endian)
  header$calMin <- readBin(conn, double(), n=1, size=4, endian=endian)

  header$sliceDuration <- readBin(conn, double(), n=1, size=4, endian=endian)
  header$toffset <- readBin(conn, double(), n=1, size=4, endian=endian)

  header$glmax <- readBin(conn, integer(), n=1, size=4, endian=endian) # unused glmax, glmin
  header$glmin <- readBin(conn, integer(), n=1, size=4, endian=endian) # unused glmax, glmin
  
  header$description <- readBin(conn, integer(), n=80, size=1, endian=endian)
  header$auxfile <- readBin(conn, integer(), n=24, size=1, endian=endian)

  header$qformCode <- readBin(conn, integer(), n=1, size=2, endian=endian)
  header$sformCode <- readBin(conn, integer(), n=1, size=2, endian=endian)
  header$quaternion <- readBin(conn, double(), n=3, size=4, endian=endian)
  
  header$qoffset <- readBin(conn, double(), n=3, size=4, endian=endian)
  header$qform <- quaternToMatrix(header$quaternion, header$qoffset, header$pixdim[2:4], header$qfac)

  sform  <- readBin(conn, double(), n=12, size=4, endian=endian)
  header$sform <- rbind(matrix(sform,3,4, byrow=T), c(0,0,0,1))
  header$intentName <- readBin(conn, character(), n=16, size=1, endian=endian)
  header$magic <- readChar(conn, nchars=4)

  header$onefile <- F
  if (substr(header$magic,2,2) == "+") {
    header$onefile <- T
  }

  header$version <- substr(header$magic,3,3)
  
  close(conn)

   
  hdr = new("NIFTIHeader", headerFile=headerFile, dataFile=dataFile, fileType=fileType, versionNum=version, encoding=header$encoding, endian=endian, voxelOffset=header$voxOffset, dataType=header$dataStorage, info=header)
  
  return(hdr)
    
}


matrixToQuatern <- function(mat) {
  xd <- sqrt(drop(crossprod(mat[1:3,1])))
  yd <- sqrt(drop(crossprod(mat[1:3,2])))
  zd <- sqrt(drop(crossprod(mat[1:3,3])))

  if (xd == 0) { mat[1,1] = 1; mat[2:3,1] = 0; xd = 1; } 
  if (yd == 0) { mat[2,2] = 1; mat[c(1,3),2] = 0; yd = 1; } 
  if (zd == 0) { mat[3,3] = 1; mat[1:2,3] = 0; zd = 1; }

  rmat = mat[1:3, 1:3]
  rmat[,1] = rmat[,1]/xd
  rmat[,2] = rmat[,2]/yd  
  rmat[,3] = rmat[,3]/zd

  ####### skipping orthogonalization of columns

  #################################################

  zd = det(rmat)
  qfac = 1

  if (zd > 0) {
    qfac = 1
  } else {
    qfac = -1
    rmat[1:3,3] = -rmat[1:3,3]
  }

  # compute quaternion parameters

  a = rmat[1,1] + rmat[2,2] + rmat[3,3] + 1
  
  if (a > .5) {
    a = .5 * sqrt(a)
    b = 0.25 * (rmat[3,2]-rmat[2,3]) / a 
    c = 0.25 * (rmat[1,3]-rmat[3,1]) / a 
    d = 0.25 * (rmat[2,1]-rmat[1,2]) / a 
   } else {                      
     xd = 1.0 + rmat[1,1] - (rmat[2,2]+rmat[3,3])   
     yd = 1.0 + rmat[2,2] - (rmat[1,1]+rmat[3,3])  
     zd = 1.0 + rmat[3,3] - (rmat[1,1]+rmat[2,2])   
     if( xd > 1.0 ){
       b = 0.5 * sqrt(xd) 
       c = 0.25* (rmat[1,2]+rmat[2,1]) / b 
       d = 0.25* (rmat[1,3]+rmat[3,1]) / b 
       a = 0.25* (rmat[3,2]-rmat[2,3]) / b 
     } else if( yd > 1.0 ){
       c = 0.5 * sqrt(yd) ;
       b = 0.25* (rmat[1,2]+rmat[2,1]) / c 
       d = 0.25* (rmat[2,3]+rmat[3,2]) / c 
       a = 0.25* (rmat[1,3]-rmat[3,1]) / c 
     } else {
       d = 0.5 * sqrt(zd) ;
       b = 0.25* (rmat[1,3]+rmat[3,1]) / d 
       c = 0.25* (rmat[2,3]+rmat[3,2]) / d 
       a = 0.25* (rmat[2,1]-rmat[1,2]) / d 
     }
     if( a < 0.0 ){ b=-b ; c=-c ; d=-d; a=-a; }
   }

  return(list(quaternion=c(b,c,d), qfac=qfac))

}


  
  

quaternToMatrix <- function(quat, origin, stepSize, qfac) {
  mat <- matrix(0, 4,4)
  mat[4,] <- c(0,0,0,1)

  a <- 1 - sum(quat^2)
  if (a < 1e-07) {
    a <- 1 /(sqrt(sum(quat^2)))
    quat <- quat*a
    a <- 0
  } else {
    a <- sqrt(a)
  }

  stepSize <- ifelse(stepSize > 0, stepSize, 1)
  xd <- stepSize[1]
  yd <- stepSize[2]
  zd <- stepSize[3]
  
  if (qfac < 0) {
    zd <- -zd
  }

  b <- quat[1]
  c <- quat[2]
  d <- quat[3]


  mat[1,1] <- (a*a+b*b-c*c-d*d) * xd
  mat[1,2] <- 2 * (b*c-a*d)     * yd
  mat[1,3] <- 2 * (b*d+a*c)     * zd
  mat[2,1] <- 2 * (b*c+a*d)     * xd
  mat[2,2] <- (a*a+c*c-b*b-d*d) * yd    
  mat[2,3] <- 2 * (c*d-a*b)     * zd
  mat[3,1] <- 2 * (b*d-a*c)     * xd
  mat[3,2] <- 2 * (c*d+a*b)     * yd
  mat[3,3] <- (a*a+d*d-c*c-b*b) * zd

  mat[1:3,4] <- origin

  return(mat)
}


getDataCode <- function(dataType) {
  if (dataType == "UNKNOWN") {
    return(0)
  }else if (dataType == "BINARY") {
    return(1)
  } else if (dataType == "UBYTE") {
    return(2)
  } else if(dataType == "SHORT") {
    return(4)
  } else if(dataType == "INT") {
    return(8)
  } else if (dataType == "FLOAT") {
    return(16)
  } else if (dataType == "DOUBLE") {
    return(64)
  } else {
    stop(paste("getDataCode: unsupported data type: ", dataType))
  }
}

  
getDataStorage <- function(code) {
  if (code == 0) {
    return("UNKNOWN")
  } else if (code == 1) {
    return("BINARY")
  } else if (code == 2) {
    return("UBYTE")
  } else if(code == 4) {
    return("SHORT")
  } else if(code == 8) {
    return("INT")
  } else if (code == 16) {
    return("FLOAT")
  } else if (code == 32) {
    return("DOUBLE")
  } else {
    stop(paste("nifti(getDataStorage): unsupported data type: ", code))
  }
}

       
checkDimensions <- function(dimvec) {
  if (any(dimvec <= 0)) {
    stop(paste("nifti(checkDimensons): illegal dimension vector in header", "\n",dimvec))
  }
}
  
getEndian <- function(conn) {
  #try little endian
  endian <- "little"
  
  hsize <- readBin(conn, integer(), 1, endian=endian)
  if (hsize != 348) {
    # might be bigendian
    endian <<- "big"
    seek(conn, 0)
    hsize <- readBin(conn, integer(), 1, endian=endian)
    if (hsize != "348") {
      stop("nifti(getEndian): header size is not 348, invalid header.")
    }
  }

  return(endian)
}

getRStorage <- function(header) {
  if (any(dataType(header) == c("BINARY", "UBYTE", "SHORT", "INTEGER", "INT", "LONG"))) {
    return("integer")
  }
  
  else if (any(dataType(header) == c("FLOAT", "DOUBLE"))) {
    return("double")
  }

  return("undefined")
}

getDataSize <- function(header) {
  if (dataType(header) == "BINARY") {
    return(1)
  }
  else if (dataType(header) == "UBYTE") {
    return(1)
  }
  else if (dataType(header) == "SHORT") {
    return(2)
  }
  else if (dataType(header) == "INTEGER") {
    return(4)
  }
  else if (dataType(header) == "INT") {
    return(4)
  }
  else if (dataType(header) == "FLOAT") {
    return(4)
  }
  else if (dataType(header) == "DOUBLE") {
    return(8)
  }
  else if (dataType(header) == "LONG") {
    return(8)
  }

  return(0)
}
  
